<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Grid</title>
    <!-- Include Alt1 library -->
    <script src="https://runeapps.org/alt1/alt1.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            width: 140px;
            height: 140px;
        }
        #map-canvas {
            width: 140px;
            height: 140px;
            background-color: rgba(0, 0, 0, 0.3);
        }
        .dropdown {
            position: absolute;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px;
            z-index: 100;
            display: none;
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: #eee;
        }
        .dropdown-item {
            padding: 3px 6px;
            cursor: pointer;
            white-space: nowrap;
        }
        .dropdown-item:hover {
            background-color: #444;
        }
        .color-item {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border: 1px solid #555;
        }
    </style>
</head>
<body>
    <canvas id="map-canvas"></canvas>
    <div id="map-dropdown" class="dropdown"></div>

    <script>
        // Check if running in Alt1
        const isAlt1 = window.alt1 && window.alt1.versionint;
        
        // Map configuration
        const MAP_SIZES = {
            small: { width: 140, height: 140 },
            medium: { width: 140, height: 140 },
            large: { width: 140, height: 140 }
        };
        
        // Key configuration
        const KEY_COLORS = ['Crimson', 'Blue', 'Yellow', 'Gold', 'Orange', 'Green', 'Purple', 'Silver'];
        const KEY_SHAPES = ['corner', 'shield', 'crescent', 'wedge', 'rectangle', 'triangle', 'diamond', 'pentagon'];
        
        // Grid state
        let mapSize = 'small';
        let gridSquares = [];
        let lastClickedSquare = null;
        let keyImages = new Map();
        let selectedColor = null;
        
        // Canvas elements
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');
        const dropdown = document.getElementById('map-dropdown');
        
        // Initialize grid squares
        function initializeGridSquares() {
            gridSquares = [];
            const rows = getGridRows();
            const cols = getGridCols();
            
            for (let r = 0; r < rows; r++) {
                gridSquares[r] = [];
                for (let c = 0; c < cols; c++) {
                    gridSquares[r][c] = { row: r, col: c, icon: null, keyColor: null, keyShape: null };
                }
            }
        }
        
        // Get grid dimensions based on map size
        function getGridCols() {
            if (mapSize === 'small') {
                return 4;
            }
            return 8; // Medium and large dungeons have 8 columns
        }
        
        function getGridRows() {
            if (mapSize === 'small') {
                return 4;
            }
            return 8; // Medium and large dungeons have 8 rows
        }
        
        // Resize canvas to fit container
        function resizeCanvas() {
            canvas.width = 140;
            canvas.height = 140;
            updateCanvas();
        }
        
        // Update the canvas with the current grid state
        function updateCanvas() {
            if (!ctx) return;
            
            // Get the map size
            const outlineWidth = canvas.width;
            const outlineHeight = canvas.height;
            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw a background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, outlineWidth, outlineHeight);
            
            // Get grid dimensions
            const gridCols = getGridCols();
            const gridRows = getGridRows();
            
            const cellWidth = outlineWidth / gridCols;
            const cellHeight = outlineHeight / gridRows;
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(200, 200, 50, 0.8)';
            ctx.lineWidth = 1;
            
            // Draw vertical grid lines
            for (let i = 1; i < gridCols; i++) {
                const lineX = Math.floor(cellWidth * i);
                ctx.beginPath();
                ctx.moveTo(lineX, 0);
                ctx.lineTo(lineX, outlineHeight);
                ctx.stroke();
            }
            
            // Draw horizontal grid lines
            for (let i = 1; i < gridRows; i++) {
                const lineY = Math.floor(cellHeight * i);
                ctx.beginPath();
                ctx.moveTo(0, lineY);
                ctx.lineTo(outlineWidth, lineY);
                ctx.stroke();
            }
            
            // Draw the map outline
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, outlineWidth, outlineHeight);
            
            // Draw coordinate labels for the corners
            ctx.fillStyle = 'white';
            ctx.font = '9px Arial';
            ctx.fillText("(0,0)", 2, outlineHeight - 2);
            ctx.fillText(`(${gridCols-1},0)`, outlineWidth - 20, outlineHeight - 2);
            ctx.fillText(`(0,${gridRows-1})`, 2, 10);
            ctx.fillText(`(${gridCols-1},${gridRows-1})`, outlineWidth - 20, 10);
            
            // Draw icons on grid squares
            drawGridIcons(cellWidth, cellHeight, gridRows, gridCols);
            
            // If we have a last clicked square, highlight it
            if (lastClickedSquare) {
                const row = lastClickedSquare.row;
                const col = lastClickedSquare.col;
                
                // Make sure the row and column are valid
                if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                    // Calculate the position of the grid square
                    const squareX = Math.floor(col * cellWidth);
                    const squareY = Math.floor((gridRows - 1 - row) * cellHeight); // Invert row to match bottom-left = 0,0
                    
                    // Draw a highlight around the square
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(squareX + 1, squareY + 1, cellWidth - 2, cellHeight - 2);
                }
            }
        }
        
        // Draw icons on the grid
        function drawGridIcons(cellWidth, cellHeight, rows, cols) {
            if (!ctx) return;
            
            // Loop through all grid squares
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    // Check if this square has a key (color and shape)
                    if (gridSquares[r] && gridSquares[r][c]) {
                        const square = gridSquares[r][c];
                        
                        if (square.keyColor && square.keyShape) {
                            // Calculate the center position of this grid square
                            const centerX = Math.floor((c * cellWidth) + (cellWidth / 2));
                            const centerY = Math.floor(((rows - 1 - r) * cellHeight) + (cellHeight / 2)); // Invert row to match bottom-left = 0,0
                            
                            // Get the image for this key
                            const keyName = `${square.keyColor}_${square.keyShape}_key`;
                            const img = keyImages.get(keyName);
                            
                            if (img && img.complete) {
                                // Draw the image on the canvas
                                try {
                                    const iconSize = Math.min(cellWidth, cellHeight) * 0.7; // 70% of cell size
                                    ctx.drawImage(
                                        img, 
                                        centerX - iconSize / 2, 
                                        centerY - iconSize / 2, 
                                        iconSize, 
                                        iconSize
                                    );
                                } catch (error) {
                                    console.error("Error drawing key image on canvas:", error);
                                    
                                    // Fallback to text if image drawing fails
                                    ctx.fillStyle = 'white';
                                    ctx.font = '10px Arial';
                                    ctx.fillText(square.keyColor.charAt(0), centerX - 4, centerY + 4);
                                }
                            } else {
                                // Fallback to text if image is not loaded
                                ctx.fillStyle = 'white';
                                ctx.font = '10px Arial';
                                ctx.fillText(square.keyColor.charAt(0), centerX - 4, centerY + 4);
                            }
                        } else if (square.icon) {
                            // Legacy support for old icon system
                            const icon = square.icon;
                            // Calculate the center position of this grid square
                            const centerX = Math.floor((c * cellWidth) + (cellWidth / 2));
                            const centerY = Math.floor(((rows - 1 - r) * cellHeight) + (cellHeight / 2)); // Invert row to match bottom-left = 0,0
                            
                            // Get the image for this icon
                            const img = keyImages.get(icon);
                            
                            if (img && img.complete) {
                                // Draw the image on the canvas
                                try {
                                    const iconSize = Math.min(cellWidth, cellHeight) * 0.7; // 70% of cell size
                                    ctx.drawImage(
                                        img, 
                                        centerX - iconSize / 2, 
                                        centerY - iconSize / 2, 
                                        iconSize, 
                                        iconSize
                                    );
                                } catch (error) {
                                    console.error("Error drawing icon image on canvas:", error);
                                    
                                    // Fallback to text if image drawing fails
                                    ctx.fillStyle = 'white';
                                    ctx.font = '10px Arial';
                                    ctx.fillText(icon.charAt(0).toUpperCase(), centerX - 4, centerY + 4);
                                }
                            } else {
                                // Fallback to text if image is not loaded
                                ctx.fillStyle = 'white';
                                ctx.font = '10px Arial';
                                ctx.fillText(icon.charAt(0).toUpperCase(), centerX - 4, centerY + 4);
                            }
                        }
                    }
                }
            }
        }
        
        // Handle clicks on the canvas
        function handleCanvasClick(e) {
            // Only process right clicks
            if (e.button === 2) {
                e.preventDefault();
                
                // Get the click position relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                // Get the grid dimensions
                const gridCols = getGridCols();
                const gridRows = getGridRows();
                
                const cellWidth = canvas.width / gridCols;
                const cellHeight = canvas.height / gridRows;
                
                // Calculate which grid square was clicked
                const col = Math.floor(clickX / cellWidth);
                const row = gridRows - 1 - Math.floor(clickY / cellHeight); // Invert row to match bottom-left = 0,0
                
                // Ensure the row and column are valid
                if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                    // Store the last clicked square
                    lastClickedSquare = { row, col };
                    
                    // Reset selected color
                    selectedColor = null;
                    
                    // Show the color dropdown at this position
                    showColorDropdown(e.clientX, e.clientY, row, col);
                    
                    // Update the canvas to show the highlight
                    updateCanvas();
                    
                    // Send message to parent window
                    if (window.opener) {
                        window.opener.postMessage({
                            type: 'grid-click',
                            row: row,
                            col: col
                        }, '*');
                    }
                }
                
                return false;
            } else if (e.button === 0) {
                // Left click - use original behavior
                // Get the click position relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                // Get the grid dimensions
                const gridCols = getGridCols();
                const gridRows = getGridRows();
                
                const cellWidth = canvas.width / gridCols;
                const cellHeight = canvas.height / gridRows;
                
                // Calculate which grid square was clicked
                const col = Math.floor(clickX / cellWidth);
                const row = gridRows - 1 - Math.floor(clickY / cellHeight); // Invert row to match bottom-left = 0,0
                
                // Ensure the row and column are valid
                if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                    // Store the last clicked square
                    lastClickedSquare = { row, col };
                    
                    // Show the original dropdown at this position
                    showDropdown(e.clientX, e.clientY, row, col);
                    
                    // Update the canvas to show the highlight
                    updateCanvas();
                    
                    // Send message to parent window
                    if (window.opener) {
                        window.opener.postMessage({
                            type: 'grid-click',
                            row: row,
                            col: col
                        }, '*');
                    }
                }
            }
        }
        
        // Show color dropdown menu
        function showColorDropdown(x, y, row, col) {
            // Position the dropdown
            dropdown.style.left = `${x}px`;
            dropdown.style.top = `${y}px`;
            
            // Clear previous content
            dropdown.innerHTML = '';
            
            // Add header
            const header = document.createElement('div');
            header.className = 'dropdown-item';
            header.style.fontWeight = 'bold';
            header.textContent = 'Select Color:';
            dropdown.appendChild(header);
            
            // Add color options
            KEY_COLORS.forEach(color => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                
                // Create color swatch
                const colorSwatch = document.createElement('span');
                colorSwatch.className = 'color-item';
                colorSwatch.style.backgroundColor = color.toLowerCase();
                item.appendChild(colorSwatch);
                
                // Add color name
                const colorName = document.createTextNode(color);
                item.appendChild(colorName);
                
                item.onclick = () => {
                    selectedColor = color;
                    hideDropdown();
                    showShapeDropdown(x, y, row, col);
                };
                
                dropdown.appendChild(item);
            });
            
            // Add clear option
            const clearItem = document.createElement('div');
            clearItem.className = 'dropdown-item';
            clearItem.textContent = 'Clear';
            clearItem.onclick = () => {
                clearKeyFromGrid(row, col);
                hideDropdown();
            };
            dropdown.appendChild(clearItem);
            
            // Show the dropdown
            dropdown.style.display = 'block';
            
            // Add click event listener to hide dropdown when clicking outside
            setTimeout(() => {
                document.addEventListener('click', hideDropdownOnClickOutside);
            }, 10);
        }
        
        // Show shape dropdown menu after color selection
        function showShapeDropdown(x, y, row, col) {
            // Position the dropdown
            dropdown.style.left = `${x}px`;
            dropdown.style.top = `${y}px`;
            
            // Clear previous content
            dropdown.innerHTML = '';
            
            // Add header
            const header = document.createElement('div');
            header.className = 'dropdown-item';
            header.style.fontWeight = 'bold';
            header.textContent = `Selected ${selectedColor} - Choose Shape:`;
            dropdown.appendChild(header);
            
            // Add shape options
            KEY_SHAPES.forEach(shape => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.textContent = shape.charAt(0).toUpperCase() + shape.slice(1);
                
                item.onclick = () => {
                    addKeyToGrid(row, col, selectedColor, shape);
                    hideDropdown();
                };
                
                dropdown.appendChild(item);
            });
            
            // Add back option
            const backItem = document.createElement('div');
            backItem.className = 'dropdown-item';
            backItem.textContent = '← Back to Colors';
            backItem.onclick = () => {
                hideDropdown();
                showColorDropdown(x, y, row, col);
            };
            dropdown.appendChild(backItem);
            
            // Show the dropdown
            dropdown.style.display = 'block';
            
            // Add click event listener to hide dropdown when clicking outside
            setTimeout(() => {
                document.addEventListener('click', hideDropdownOnClickOutside);
            }, 10);
        }
        
        // Show dropdown menu for selecting icons (original functionality)
        function showDropdown(x, y, row, col) {
            // Position the dropdown
            dropdown.style.left = `${x}px`;
            dropdown.style.top = `${y}px`;
            
            // Clear previous content
            dropdown.innerHTML = '';
            
            // Add dropdown items
            const icons = ['blue-key', 'red-key', 'green-key', 'yellow-key', 'boss', 'start', 'gate', 'clear'];
            
            icons.forEach(icon => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                
                if (icon === 'clear') {
                    item.textContent = 'Clear';
                    item.onclick = () => {
                        addIconToGrid(row, col, null);
                        hideDropdown();
                    };
                } else {
                    item.textContent = icon.replace('-', ' ').charAt(0).toUpperCase() + icon.replace('-', ' ').slice(1);
                    item.onclick = () => {
                        addIconToGrid(row, col, icon);
                        hideDropdown();
                    };
                }
                
                dropdown.appendChild(item);
            });
            
            // Add option for new key system
            const newKeyItem = document.createElement('div');
            newKeyItem.className = 'dropdown-item';
            newKeyItem.style.fontWeight = 'bold';
            newKeyItem.textContent = 'Use Key System →';
            newKeyItem.onclick = () => {
                hideDropdown();
                showColorDropdown(x, y, row, col);
            };
            dropdown.appendChild(newKeyItem);
            
            // Show the dropdown
            dropdown.style.display = 'block';
            
            // Add click event listener to hide dropdown when clicking outside
            setTimeout(() => {
                document.addEventListener('click', hideDropdownOnClickOutside);
            }, 10);
        }
        
        // Hide dropdown when clicking outside
        function hideDropdownOnClickOutside(e) {
            if (!dropdown.contains(e.target)) {
                hideDropdown();
            }
        }
        
        // Hide the dropdown
        function hideDropdown() {
            dropdown.style.display = 'none';
            document.removeEventListener('click', hideDropdownOnClickOutside);
        }
        
        // Add icon to grid (original functionality)
        function addIconToGrid(row, col, icon) {
            if (gridSquares[row] && gridSquares[row][col]) {
                gridSquares[row][col].icon = icon;
                // Clear any key data
                gridSquares[row][col].keyColor = null;
                gridSquares[row][col].keyShape = null;
                updateCanvas();
                
                // Send update to parent window
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'grid-update',
                        row: row,
                        col: col,
                        icon: icon
                    }, '*');
                }
            }
        }
        
        // Add key to grid (new functionality)
        function addKeyToGrid(row, col, color, shape) {
            if (gridSquares[row] && gridSquares[row][col]) {
                gridSquares[row][col].keyColor = color;
                gridSquares[row][col].keyShape = shape;
                // Clear any old icon data
                gridSquares[row][col].icon = null;
                updateCanvas();
                
                // Send update to parent window
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'grid-update',
                        row: row,
                        col: col,
                        keyColor: color,
                        keyShape: shape
                    }, '*');
                }
            }
        }
        
        // Clear key from grid
        function clearKeyFromGrid(row, col) {
            if (gridSquares[row] && gridSquares[row][col]) {
                gridSquares[row][col].keyColor = null;
                gridSquares[row][col].keyShape = null;
                gridSquares[row][col].icon = null;
                updateCanvas();
                
                // Send update to parent window
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'grid-update',
                        row: row,
                        col: col,
                        keyColor: null,
                        keyShape: null,
                        icon: null
                    }, '*');
                }
            }
        }
        
        // Preload key images
        function preloadKeyImages() {
            // Load original icons
            const originalIcons = [
                { name: 'blue-key', path: 'assets/blue-key.png' },
                { name: 'red-key', path: 'assets/red-key.png' },
                { name: 'green-key', path: 'assets/green-key.png' },
                { name: 'yellow-key', path: 'assets/yellow-key.png' },
                { name: 'boss', path: 'assets/boss.png' },
                { name: 'start', path: 'assets/start.png' },
                { name: 'gate', path: 'assets/gate.png' }
            ];
            
            // Load all color-shape combinations
            const keyImages = [];
            KEY_COLORS.forEach(color => {
                KEY_SHAPES.forEach(shape => {
                    keyImages.push({
                        name: `${color}_${shape}_key`,
                        path: `assets/keys/${color}_${shape}_key.png`
                    });
                });
            });
            
            // Combine both sets of images to load
            const imagesToLoad = [...originalIcons, ...keyImages];
            let loadedCount = 0;
            
            imagesToLoad.forEach(img => {
                const image = new Image();
                image.onload = () => {
                    loadedCount++;
                    if (loadedCount === imagesToLoad.length) {
                        console.log('All images loaded');
                        updateCanvas();
                    }
                };
                image.onerror = () => {
                    console.error(`Failed to load image: ${img.path}`);
                    loadedCount++;
                };
                image.src = img.path;
                keyImages.set(img.name, image);
            });
        }
        
        // Initialize the map
        function initMap() {
            initializeGridSquares();
            preloadKeyImages();
            resizeCanvas();
            
            // Set up event listeners
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('contextmenu', handleCanvasClick);
            window.addEventListener('resize', resizeCanvas);
        }
        
        // Communication with main window
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type) {
                switch(event.data.type) {
                    case 'grid-sync':
                        if (event.data.gridSquares) {
                            gridSquares = event.data.gridSquares;
                            updateCanvas();
                        }
                        break;
                    case 'map-size':
                        if (event.data.size) {
                            mapSize = event.data.size;
                            initializeGridSquares();
                            updateCanvas();
                        }
                        break;
                }
            }
        });
        
        // Notify parent window that helper is loaded
        if (window.opener) {
            window.opener.postMessage({ type: 'helper-loaded' }, '*');
        }
        
        // If in Alt1, set up additional functionality
        if (isAlt1) {
            // Let Alt1 detect when this page is fully loaded
            if (window.alt1 && window.alt1.identifyAppUrl) {
                window.alt1.identifyAppUrl('./appconfig.json');
            }
            
            console.log("Running in Alt1 environment");
        } else {
            console.log("Not running in Alt1 environment");
        }
        
        // Initialize the map when the page loads
        initMap();
    </script>
</body>
</html> 
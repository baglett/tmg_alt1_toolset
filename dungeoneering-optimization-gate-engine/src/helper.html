<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Grid</title>
    <!-- Include Alt1 library -->
    <script src="https://runeapps.org/alt1/alt1.js"></script>
    <script>
        // Identify to Alt1 as early as possible
        if (window.alt1 && window.alt1.identifyAppUrl) {
            window.alt1.identifyAppUrl('./appconfig.json');
            console.log("Identified app to Alt1 early");
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            width: 140px;
            height: 140px;
        }
        #map-canvas {
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
        }
        .dropdown {
            position: absolute;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px;
            z-index: 100;
            display: none;
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: #eee;
        }
        .dropdown-item {
            padding: 3px 6px;
            cursor: pointer;
            white-space: nowrap;
        }
        .dropdown-item:hover {
            background-color: #444;
        }
        .color-item {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border: 1px solid #555;
        }
    </style>
</head>
<body>
    <canvas id="map-canvas"></canvas>
    <div id="map-dropdown" class="dropdown"></div>

    <script>
        // Check if we're running in Alt1 - multiple detection methods
        const isAlt1 = (function() {
            // Method 1: Check for window.alt1
            if (typeof window.alt1 !== 'undefined') {
                console.log("Alt1 detected via window.alt1");
                return true;
            }
            
            // Method 2: Check for Alt1 API
            if (typeof window.A1lib !== 'undefined') {
                console.log("Alt1 detected via A1lib");
                return true;
            }
            
            // Method 3: Check URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('alt1')) {
                console.log("Alt1 detected via URL parameter");
                return true;
            }
            
            // Method 4: Check if the URL contains alt1://
            if (window.location.href.includes('alt1://')) {
                console.log("Alt1 detected via URL protocol");
                return true;
            }
            
            console.log("Alt1 not detected");
            return false;
        })();
        
        // Map configuration
        const MAP_SIZES = {
            small: { width: 140, height: 140 },
            medium: { width: 140, height: 280 },
            large: { width: 280, height: 280 }
        };
        
        // Key configuration
        const KEY_COLORS = ['Crimson', 'Blue', 'Yellow', 'Gold', 'Orange', 'Green', 'Purple', 'Silver'];
        const KEY_SHAPES = ['corner', 'shield', 'crescent', 'wedge', 'rectangle', 'triangle', 'diamond', 'pentagon'];
        
        // Grid state
        let mapSize = 'small';
        let gridSquares = [];
        let lastClickedSquare = null;
        let keyImages = new Map();
        let selectedColor = null;
        
        // Canvas elements
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');
        const dropdown = document.getElementById('map-dropdown');
        
        // Initialize grid squares
        function initializeGridSquares() {
            gridSquares = [];
            const rows = getGridRows();
            const cols = getGridCols();
            
            for (let r = 0; r < rows; r++) {
                gridSquares[r] = [];
                for (let c = 0; c < cols; c++) {
                    gridSquares[r][c] = { row: r, col: c, keyColor: null, keyShape: null };
                }
            }
        }
        
        // Get grid dimensions based on map size
        function getGridCols() {
            if (mapSize === 'small') {
                return 4;
            }
            return 8; // Medium and large dungeons have 8 columns
        }
        
        function getGridRows() {
            if (mapSize === 'small') {
                return 4;
            }
            return 8; // Medium and large dungeons have 8 rows
        }
        
        // Update body size based on map size
        function updateBodySize() {
            const size = MAP_SIZES[mapSize];
            document.body.style.width = `${size.width}px`;
            document.body.style.height = `${size.height}px`;
        }
        
        // Resize canvas to fit container
        function resizeCanvas() {
            const size = MAP_SIZES[mapSize];
            canvas.width = size.width;
            canvas.height = size.height;
            updateCanvas();
        }
        
        // Update the canvas with the current grid state
        function updateCanvas() {
            if (!ctx) return;
            
            // Get the map size
            const outlineWidth = canvas.width;
            const outlineHeight = canvas.height;
            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // If we have a background image from Alt1, draw it
            if (window.alt1 && window.alt1.capture) {
                try {
                    // Get the map area relative to the anchor point
                    // This will capture the screen area that corresponds to the tracked minimap
                    const mapImg = window.alt1.capture(0, 0, outlineWidth, outlineHeight);
                    if (mapImg) {
                        const imgData = ctx.createImageData(outlineWidth, outlineHeight);
                        imgData.data.set(mapImg.data);
                        ctx.putImageData(imgData, 0, 0);
                        
                        // Add a semi-transparent overlay to make the grid more visible
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.fillRect(0, 0, outlineWidth, outlineHeight);
                    } else {
                        console.error('Failed to capture map background: capture returned null');
                        // Draw fallback dark background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.fillRect(0, 0, outlineWidth, outlineHeight);
                    }
                } catch (e) {
                    console.error('Failed to capture map background:', e);
                    // Draw fallback dark background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, outlineWidth, outlineHeight);
                }
            } else {
                // Draw fallback dark background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, outlineWidth, outlineHeight);
            }
            
            // Get grid dimensions
            const gridCols = getGridCols();
            const gridRows = getGridRows();
            
            const cellWidth = outlineWidth / gridCols;
            const cellHeight = outlineHeight / gridRows;
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(200, 200, 50, 0.8)';
            ctx.lineWidth = 1;
            
            // Draw vertical grid lines
            for (let i = 1; i < gridCols; i++) {
                const lineX = Math.floor(cellWidth * i);
                ctx.beginPath();
                ctx.moveTo(lineX, 0);
                ctx.lineTo(lineX, outlineHeight);
                ctx.stroke();
            }
            
            // Draw horizontal grid lines
            for (let i = 1; i < gridRows; i++) {
                const lineY = Math.floor(cellHeight * i);
                ctx.beginPath();
                ctx.moveTo(0, lineY);
                ctx.lineTo(outlineWidth, lineY);
                ctx.stroke();
            }
            
            // Draw the map outline
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, outlineWidth, outlineHeight);
            
            // Draw map size info
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            ctx.fillText(`${mapSize.toUpperCase()} MAP (${outlineWidth}x${outlineHeight})`, 5, 10);
            
            // Draw icons on grid squares
            drawGridIcons(cellWidth, cellHeight, gridRows, gridCols);
            
            // If we have a last clicked square, highlight it
            if (lastClickedSquare) {
                const row = lastClickedSquare.row;
                const col = lastClickedSquare.col;
                
                // Make sure the row and column are valid
                if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                    // Calculate the position of the grid square
                    const squareX = Math.floor(col * cellWidth);
                    const squareY = Math.floor((gridRows - 1 - row) * cellHeight); // Invert row to match bottom-left = 0,0
                    
                    // Draw a highlight around the square
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(squareX + 1, squareY + 1, cellWidth - 2, cellHeight - 2);
                }
            }
        }
        
        // Preload key images
        function preloadKeyImages() {
            KEY_COLORS.forEach(color => {
                KEY_SHAPES.forEach(shape => {
                    const keyName = `${color.toLowerCase()}_${shape.toLowerCase()}_key`;
                    const img = new Image();
                    img.src = `assets/keys/${keyName}.png`;
                    img.onload = () => {
                        keyImages.set(keyName, img);
                        console.log(`Loaded key image: ${keyName}`);
                    };
                    img.onerror = () => {
                        console.error(`Failed to load key image: ${keyName}`);
                    };
                });
            });
        }
        
        // Draw icons on the grid
        function drawGridIcons(cellWidth, cellHeight, rows, cols) {
            if (!ctx) return;
            
            // Loop through all grid squares
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    // Check if this square has a key (color and shape)
                    if (gridSquares[r] && gridSquares[r][c]) {
                        const square = gridSquares[r][c];
                        
                        if (square.keyColor && square.keyShape) {
                            // Calculate the center position of this grid square
                            const centerX = Math.floor((c * cellWidth) + (cellWidth / 2));
                            const centerY = Math.floor(((rows - 1 - r) * cellHeight) + (cellHeight / 2)); // Invert row to match bottom-left = 0,0
                            
                            // Try to draw the key image
                            const keyName = `${square.keyColor.toLowerCase()}_${square.keyShape.toLowerCase()}_key`;
                            const img = keyImages.get(keyName);
                            
                            if (img && img.complete) {
                                try {
                                    const iconSize = Math.min(cellWidth, cellHeight) * 0.7; // 70% of cell size
                                    ctx.drawImage(
                                        img,
                                        centerX - iconSize / 2,
                                        centerY - iconSize / 2,
                                        iconSize,
                                        iconSize
                                    );
                                } catch (error) {
                                    console.error(`Error drawing key image ${keyName}:`, error);
                                    drawFallbackKey(ctx, centerX, centerY, square.keyColor, square.keyShape);
                                }
                            } else {
                                // Use fallback if image isn't loaded
                                drawFallbackKey(ctx, centerX, centerY, square.keyColor, square.keyShape);
                            }
                        }
                    }
                }
            }
        }
        
        // Helper function to draw fallback key
        function drawFallbackKey(ctx, centerX, centerY, color, shape) {
            // Draw colored background with semi-transparency
            ctx.fillStyle = `${color.toLowerCase()}88`; // Add 88 for 50% transparency
            const size = 24; // Slightly larger size
            ctx.fillRect(centerX - size/2, centerY - size/2, size, size);
            
            // Draw white border
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(centerX - size/2, centerY - size/2, size, size);
            
            // Draw shape letter
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            let letter = shape.charAt(0).toUpperCase();
            ctx.fillText(letter, centerX, centerY);
        }
        
        // Handle clicks on the canvas
        function handleCanvasClick(e) {
            // Only process right clicks
            if (e.button === 2) {
                e.preventDefault();
                
                // Get the click position relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                // Get the grid dimensions
                const gridCols = getGridCols();
                const gridRows = getGridRows();
                
                const cellWidth = canvas.width / gridCols;
                const cellHeight = canvas.height / gridRows;
                
                // Calculate which grid square was clicked
                const col = Math.floor(clickX / cellWidth);
                const row = gridRows - 1 - Math.floor(clickY / cellHeight); // Invert row to match bottom-left = 0,0
                
                // Ensure the row and column are valid
                if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                    // Store the last clicked square
                    lastClickedSquare = { row, col };
                    
                    // Reset selected color
                    selectedColor = null;
                    
                    // Show the color dropdown at this position
                    showColorDropdown(e.clientX, e.clientY, row, col);
                    
                    // Update the canvas to show the highlight
                    updateCanvas();
                    
                    // Send message to parent window
                    if (window.opener) {
                        window.opener.postMessage({
                            type: 'grid-click',
                            row: row,
                            col: col
                        }, '*');
                    }
                }
                
                return false;
            }
        }
        
        // Show color dropdown menu
        function showColorDropdown(x, y, row, col) {
            // Position the dropdown
            dropdown.style.left = `${x}px`;
            dropdown.style.top = `${y}px`;
            
            // Clear previous content
            dropdown.innerHTML = '';
            
            // Add color options
            KEY_COLORS.forEach(color => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                
                // Create color swatch
                const colorSwatch = document.createElement('span');
                colorSwatch.className = 'color-item';
                colorSwatch.style.backgroundColor = color.toLowerCase();
                item.appendChild(colorSwatch);
                
                // Add color name
                const colorName = document.createTextNode(color);
                item.appendChild(colorName);
                
                item.onclick = () => {
                    selectedColor = color;
                    hideDropdown();
                    showShapeDropdown(x, y, row, col);
                };
                
                dropdown.appendChild(item);
            });
            
            // Show the dropdown
            dropdown.style.display = 'block';
            
            // Add click event listener to hide dropdown when clicking outside
            setTimeout(() => {
                document.addEventListener('click', hideDropdownOnClickOutside);
            }, 10);
        }
        
        // Show shape dropdown menu after color selection
        function showShapeDropdown(x, y, row, col) {
            // Position the dropdown
            dropdown.style.left = `${x}px`;
            dropdown.style.top = `${y}px`;
            
            // Clear previous content
            dropdown.innerHTML = '';
            
            // Add shape options
            KEY_SHAPES.forEach(shape => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.textContent = shape.charAt(0).toUpperCase() + shape.slice(1);
                
                item.onclick = () => {
                    addKeyToGrid(row, col, selectedColor, shape);
                    hideDropdown();
                };
                
                dropdown.appendChild(item);
            });
            
            // Show the dropdown
            dropdown.style.display = 'block';
            
            // Add click event listener to hide dropdown when clicking outside
            setTimeout(() => {
                document.addEventListener('click', hideDropdownOnClickOutside);
            }, 10);
        }
        
        // Hide dropdown when clicking outside
        function hideDropdownOnClickOutside(e) {
            if (!dropdown.contains(e.target)) {
                hideDropdown();
            }
        }
        
        // Hide the dropdown
        function hideDropdown() {
            dropdown.style.display = 'none';
            document.removeEventListener('click', hideDropdownOnClickOutside);
        }
        
        // Add key to grid
        function addKeyToGrid(row, col, color, shape) {
            if (gridSquares[row] && gridSquares[row][col]) {
                gridSquares[row][col].keyColor = color;
                gridSquares[row][col].keyShape = shape;
                updateCanvas();
                
                // Send update to parent window
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'grid-update',
                        row: row,
                        col: col,
                        keyColor: color,
                        keyShape: shape
                    }, '*');
                }
            }
        }
        
        // Clear key from grid
        function clearKeyFromGrid(row, col) {
            if (gridSquares[row] && gridSquares[row][col]) {
                gridSquares[row][col].keyColor = null;
                gridSquares[row][col].keyShape = null;
                updateCanvas();
                
                // Send update to parent window
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'grid-update',
                        row: row,
                        col: col,
                        keyColor: null,
                        keyShape: null
                    }, '*');
                }
            }
        }
        
        // Initialize the map
        function initMap() {
            preloadKeyImages();
            initializeGridSquares();
            updateBodySize();
            resizeCanvas();
            
            // Set up event listeners
            canvas.addEventListener('contextmenu', handleCanvasClick);
            window.addEventListener('resize', resizeCanvas);

            // Start periodic updates of the background if in Alt1
            if (window.alt1) {
                // Start periodic updates
                setInterval(() => {
                    updateCanvas();
                }, 500); // Update every 500ms
            }
            
            // Request the current anchor point from the parent window
            if (window.opener) {
                console.log('Requesting anchor point from parent window');
                window.opener.postMessage({ type: 'request-anchor' }, '*');
                
                // Also request grid state
                window.opener.postMessage({ type: 'request-grid' }, '*');
            }
        }
        
        // Communication with main window
        window.addEventListener('message', function(event) {
            try {
                if (event.data && event.data.type) {
                    console.log(`Received message from parent: ${event.data.type}`);
                    
                    switch(event.data.type) {
                        case 'grid-sync':
                            if (event.data.gridSquares) {
                                gridSquares = event.data.gridSquares;
                                console.log('Updated grid squares from parent');
                                updateCanvas();
                            }
                            break;
                        case 'map-size':
                            if (event.data.size) {
                                mapSize = event.data.size;
                                console.log(`Updated map size to: ${mapSize}`);
                                initializeGridSquares();
                                updateBodySize();
                                resizeCanvas();
                            }
                            break;
                        case 'anchor-update':
                            // Handle anchor point updates
                            if (event.data.x !== undefined && event.data.y !== undefined) {
                                console.log(`Received anchor update: (${event.data.x}, ${event.data.y})`);
                                
                                // Store the anchor point coordinates for screen capture
                                if (window.alt1 && window.alt1.setScreenCaptureBounds) {
                                    try {
                                        // Calculate the capture area based on the anchor point
                                        const size = MAP_SIZES[mapSize];
                                        
                                        // Get offset and outline size values from the message or use defaults
                                        const xOffset = event.data.xOffset !== undefined ? event.data.xOffset : 6;
                                        const yOffset = event.data.yOffset !== undefined ? event.data.yOffset : -12;
                                        const outlineWidth = event.data.outlineWidth !== undefined ? event.data.outlineWidth : -5;
                                        const outlineHeight = event.data.outlineHeight !== undefined ? event.data.outlineHeight : 0;
                                        
                                        const width = size.width + outlineWidth;
                                        const height = size.height + outlineHeight;
                                        const x = Math.floor(event.data.x - width + xOffset);
                                        const y = Math.floor(event.data.y + yOffset);
                                        
                                        // Set the capture bounds for Alt1
                                        window.alt1.setScreenCaptureBounds(x, y, width, height);
                                        console.log(`Set capture bounds to: ${x},${y},${width},${height}`);
                                        
                                        // Add debug info to the canvas
                                        if (ctx) {
                                            ctx.fillStyle = 'white';
                                            ctx.font = '10px Arial';
                                            ctx.fillText(`Capture: ${x},${y},${width}x${height}`, 5, 10);
                                        }
                                    } catch (e) {
                                        console.error('Failed to set screen capture bounds:', e);
                                    }
                                } else {
                                    console.warn('Alt1 screen capture API not available');
                                }
                                updateCanvas();
                            }
                            break;
                        default:
                            console.log(`Unhandled message type: ${event.data.type}`);
                    }
                }
            } catch (error) {
                console.error('Error handling message from parent:', error);
            }
        });
        
        // Notify parent window that helper is loaded and request data
        function requestDataFromParent() {
            console.log('Attempting to connect to parent window...');
            
            if (window.opener) {
                console.log('Parent window detected, sending helper-loaded message');
                
                try {
                    // Notify parent that helper is loaded
                    window.opener.postMessage({ type: 'helper-loaded' }, '*');
                    
                    // Request the anchor point and grid data
                    console.log('Requesting data from parent window');
                    window.opener.postMessage({ type: 'request-anchor' }, '*');
                    window.opener.postMessage({ type: 'request-grid' }, '*');
                    
                    return true;
                } catch (e) {
                    console.error('Error communicating with parent window:', e);
                    return false;
                }
            } else {
                console.warn('No parent window detected');
                return false;
            }
        }
        
        // Try to request data immediately
        let dataRequested = requestDataFromParent();
        
        // If not successful, retry a few times with increasing delays
        if (!dataRequested) {
            let retryCount = 0;
            const maxRetries = 10;
            const retryInterval = setInterval(() => {
                retryCount++;
                console.log(`Retrying data request (${retryCount}/${maxRetries})...`);
                dataRequested = requestDataFromParent();
                
                if (dataRequested || retryCount >= maxRetries) {
                    clearInterval(retryInterval);
                    if (!dataRequested) {
                        console.warn('Failed to connect to parent window after multiple attempts');
                    } else {
                        console.log('Successfully connected to parent window on retry');
                    }
                }
            }, 500 * retryCount); // Increasing delay between retries
        }
        
        // If in Alt1, set up additional functionality
        if (isAlt1) {
            console.log("Running in Alt1 environment");
        } else {
            console.log("Not running in Alt1 environment - some features may not work properly");
        }
        
        // Initialize the map when the page loads
        initMap();
    </script>
</body>
</html> 
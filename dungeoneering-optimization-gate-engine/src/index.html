<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeoneering Optimization Gate Engine</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #36393f;
            color: #dcddde;
            overflow: hidden; /* Prevent scrollbars */
        }
        
        /* Main container */
        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        
        /* Sidebar styles */
        .sidebar {
            width: 30px;
            background-color: #2f3136;
            border-right: 1px solid #202225;
            flex-shrink: 0;
        }
        
        /* Header section of sidebar */
        .sidebar-header {
            padding: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 1px solid #202225;
        }
        
        /* App title in sidebar */
        .sidebar-title {
            display: none;
        }
        
        /* Navigation links container */
        .nav-links {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        /* Individual nav items */
        .nav-item {
            padding: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .nav-item:hover {
            background-color: #40444b;
        }
        
        .nav-item.active {
            background-color: #5865f2;
        }
        
        /* Icon in nav items */
        .nav-icon {
            font-size: 12px;
            min-width: 12px;
            text-align: center;
        }
        
        /* Text in nav items */
        .nav-text {
            display: none;
        }
        
        /* Main content area */
        .content {
            flex: 1;
            padding: 5px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        /* Content area in compact mode */
        .compact-mode .content {
            padding: 0;
        }
        
        /* View containers */
        .view {
            display: none;
            overflow: hidden;
        }
        
        .view.active {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        /* Map view in compact mode */
        .compact-mode #map-view {
            padding: 0;
            margin: 0;
        }

        /* Map wrapper in compact mode */
        .compact-mode .map-wrapper {
            padding: 0;
            margin: 0;
        }

        /* View header styles */
        .view-header {
            margin: 0 0 5px 0;
            font-size: 16px;
            text-align: center;
            padding-bottom: 3px;
            border-bottom: 1px solid #40444b;
        }

        .map-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }

        .map-container {
            background-color: #202225;
            border: 1px solid #40444b;
            position: relative;
            overflow: hidden;
            transition: width 0.3s, height 0.3s;
            cursor: pointer;
            flex-shrink: 0;
            flex-grow: 0;
            padding: 0;
            margin: 0;
        }

        /* In compact mode, remove border */
        .compact-mode .map-container {
            border: none;
        }

        .map-container.small {
            width: 140px;
            height: 140px;
            min-width: 140px;
            min-height: 140px;
            max-width: 140px;
            max-height: 140px;
        }

        .map-container.medium {
            width: 140px;
            height: 280px;
            min-width: 140px;
            min-height: 280px;
            max-width: 140px;
            max-height: 280px;
        }

        .map-container.large {
            width: 280px;
            height: 280px;
            min-width: 280px;
            min-height: 280px;
            max-width: 280px;
            max-height: 280px;
        }

        .map-grid {
            display: grid;
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            gap: 0;
        }

        .map-grid.small {
            grid-template-columns: repeat(4, 35px);
            grid-template-rows: repeat(4, 35px);
        }

        .map-grid.medium {
            grid-template-columns: repeat(4, 35px);
            grid-template-rows: repeat(8, 35px);
        }

        .map-grid.large {
            grid-template-columns: repeat(8, 35px);
            grid-template-rows: repeat(8, 35px);
        }

        .grid-cell {
            border: 1px solid #40444b;
            background-color: #2f3136;
            width: 35px;
            height: 35px;
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Alt1 specific styles */
        .alt1-info {
            font-size: 12px;
            color: #a0a0a0;
            margin-top: 5px;
            text-align: center;
        }

        /* Save feedback message */
        .save-feedback {
            font-size: 12px;
            color: #4CAF50;
            margin-top: 5px;
            height: 16px;
            transition: opacity 0.5s;
            opacity: 0;
            text-align: center;
        }
        
        .save-feedback.visible {
            opacity: 1;
        }

        /* Compact mode for small windows */
        .compact-mode .view-header {
            font-size: 14px;
            margin-bottom: 3px;
        }

        .compact-mode .map-info {
            font-size: 11px;
            margin-top: 3px;
        }

        .compact-mode .alt1-info {
            display: none;
        }
        
        /* Alt1 Status Indicator Styles */
        .status-row {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-top: 2px;
        }
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        .status-indicator.detected {
            background-color: #4CAF50;
            box-shadow: 0 0 3px #4CAF50;
        }
        .status-indicator.not-detected {
            background-color: #ff4444;
            box-shadow: 0 0 3px #ff4444;
        }
        .status-text {
            font-weight: bold;
            font-size: 11px;
        }
        .status-text.detected {
            color: #4CAF50;
        }
        .status-text.not-detected {
            color: #ff4444;
        }
        .alt1-install-link {
            display: inline-block;
            background-color: #7289da;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            text-decoration: none;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .alt1-install-link:hover {
            background-color: #5b6eae;
        }
        
        /* Context Menu Styles */
        .context-menu {
            position: absolute;
            background-color: #36393f;
            border: 1px solid #202225;
            border-radius: 3px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            overflow: hidden;
            max-width: 140px; /* Reduced from 160px */
            font-size: 11px; /* Smaller font size */
            width: auto; /* Allow menu to shrink to content */
        }
        
        .context-menu.visible {
            display: block;
        }
        
        .context-menu-section {
            padding: 1px; /* Minimal padding */
            border-bottom: 1px solid #202225;
        }
        
        .context-menu-section:last-child {
            border-bottom: none;
        }
        
        .context-menu-title {
            font-size: 10px; /* Smaller title */
            color: #b9bbbe;
            margin: 1px 0; /* Minimal margin */
            font-weight: bold;
            text-align: center; /* Center the title */
        }
        
        .color-options {
            display: flex;
            flex-direction: column; /* Stack rows vertically */
            gap: 1px; /* Minimal gap */
            align-items: center; /* Center items */
        }
        
        .color-row {
            display: flex;
            flex-direction: row;
            gap: 2px;
            width: 100%;
        }
        
        .color-option {
            width: 60px; /* Reduced from 70px */
            height: 16px; /* Reduced from 18px */
            border-radius: 2px;
            cursor: pointer;
            border: 1px solid #202225;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin: 1px 0; /* Vertical margin only */
            font-size: 9px; /* Reduced from 10px */
            padding: 0; /* No padding */
            text-align: center; /* Center text */
            flex: 1; /* Make options take equal width */
        }
        
        .color-option:hover {
            transform: scale(1.02);
            box-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
        }
        
        .shape-options {
            display: flex;
            flex-direction: column; /* Stack rows vertically */
            gap: 1px; /* Minimal gap */
            align-items: center; /* Center items */
        }
        
        .shape-row {
            display: flex;
            flex-direction: row;
            gap: 2px;
            width: 100%;
        }
        
        .shape-option {
            width: 60px; /* Reduced from 70px */
            height: 16px; /* Reduced from 18px */
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 0 1px; /* Minimal horizontal padding */
            cursor: pointer;
            background-color: #40444b;
            border-radius: 2px;
            font-size: 9px; /* Reduced from 10px */
            margin: 1px 0; /* Vertical margin only */
            flex: 1; /* Make options take equal width */
        }
        
        .shape-option:hover {
            background-color: #5865f2;
        }
        
        .shape-preview {
            width: 10px; /* Reduced from 12px */
            height: 10px; /* Reduced from 12px */
            margin-right: 2px; /* Minimal margin */
        }
        
        /* Grid cell with key image */
        .grid-cell img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Shape menu specific styles to match color menu width */
        #shape-menu {
            width: 140px; /* Match the max-width of context-menu */
        }

        /* Anchor point styles */
        .anchor-point-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 2px;
        }

        .coordinates-display {
            font-family: monospace;
            font-size: 11px;
            color: #aaaaaa;
            margin-top: 4px;
            min-height: 14px;
            background-color: #202225;
            padding: 2px 4px;
            border-radius: 2px;
        }

        /* Crosshair styles for anchor point placement */
        .crosshair {
            position: absolute;
            pointer-events: none;
            z-index: 9999;
            display: none;
        }

        .crosshair.active {
            display: block;
        }

        .crosshair-h, .crosshair-v {
            position: absolute;
            background-color: rgba(255, 255, 0, 0.7);
        }

        .crosshair-h {
            height: 1px;
            width: 100%;
            top: 50%;
            left: 0;
        }

        .crosshair-v {
            width: 1px;
            height: 100%;
            left: 50%;
            top: 0;
        }

        .crosshair-center {
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: rgba(255, 255, 0, 0.9);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .anchor-active {
            color: #4CAF50;
            font-weight: bold;
        }

        .anchor-inactive {
            color: #aaaaaa;
        }

        /* Settings form styles */
        .settings-form {
            padding: 15px;
            background-color: #2f3136;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        /* Screen Capture Preview styles */
        .screen-capture-preview {
            margin-top: 10px;
            border: 1px solid #4f545c;
            border-radius: 4px;
            padding: 10px;
            background-color: #202225;
            display: flex;
            justify-content: center;
        }
        
        #capturePreviewCanvas {
            border: 2px solid #43b581;
            background-color: #000;
            max-width: 100%;
            height: auto;
        }
        
        /* Alt1 Status styles */
        #alt1-status-indicator {
            margin-top: 5px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .status-label {
            font-weight: bold;
        }
        
        .status-value {
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .status-ok {
            background-color: #43b581;
            color: #fff;
        }
        
        .status-error {
            background-color: #f04747;
            color: #fff;
        }
        
        /* Form group styles */
        .form-group {
            margin-bottom: 6px;
            padding: 5px;
            background-color: #2f3136;
            border-radius: 3px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 2px;
            font-weight: bold;
            font-size: 12px;
            color: #b9bbbe;
        }
        
        .form-group select {
            width: 100%;
            padding: 4px;
            background-color: #40444b;
            color: #dcddde;
            border: 1px solid #202225;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .form-group select:focus {
            outline: none;
            border-color: #5865f2;
        }
        
        .btn {
            padding: 4px 8px;
            background-color: #5865f2;
            color: #ffffff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            min-width: 90px;
            text-align: center;
        }
        
        .btn:hover {
            background-color: #4752c4;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="nav-icon">üîç</div>
            </div>
            <ul class="nav-links">
                <li class="nav-item active" data-view="settings-view" onclick="showView('settings-view', this)">
                    <div class="nav-icon">‚öôÔ∏è</div>
                </li>
                <li class="nav-item" data-view="map-view" onclick="showView('map-view', this)">
                    <div class="nav-icon">üó∫Ô∏è</div>
                </li>
            </ul>
        </div>
        
        <!-- Content area -->
        <div class="content">
            <div class="view" id="map-view">
                <div class="map-wrapper">
                    <div id="map-container" class="map-container small">
                        <div id="map-grid" class="map-grid small"></div>
                    </div>
                </div>
            </div>
            
            <div class="view active" id="settings-view">
                <h2 class="view-header">Settings</h2>
                <div class="settings-form">
                    <div class="form-group">
                        <label for="dungeon-size">Dungeon Size:</label>
                        <select id="dungeon-size" onchange="updateDungeonSize(this.value)">
                            <option value="small">Small (4x4)</option>
                            <option value="medium">Medium (4x8)</option>
                            <option value="large">Large (8x8)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Anchor Point:</label>
                        <div class="anchor-point-controls">
                            <button id="set-anchor-button" class="btn" onclick="startAnchorPointPlacement()">Set Anchor</button>
                            <span id="anchor-status" class="status-text">Not set</span>
                        </div>
                        <div id="anchor-coordinates" class="coordinates-display"></div>
                    </div>
                    
                    <!-- Screen Capture Preview Section -->
                    <div class="form-group">
                        <label>Screen Capture:</label>
                        <div class="screen-capture-preview">
                            <canvas id="capturePreviewCanvas" width="280" height="280"></canvas>
                        </div>
                    </div>
                    
                    <div class="form-group" id="alt1-status-section">
                        <label>Alt1 Status:</label>
                        <div id="alt1-status-indicator">
                            <!-- Alt1 status indicator will be inserted here by JavaScript -->
                        </div>
                    </div>
                    <div id="save-feedback" class="save-feedback"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu for Grid Cells -->
    <div id="context-menu" class="context-menu">
        <div class="context-menu-section">
            <div class="context-menu-title">Select Color</div>
            <div class="color-options">
                <div class="color-row">
                    <div class="color-option" style="background-color: #333333; color: #ffff00;" data-color="Yellow" title="Yellow">Yellow</div>
                    <div class="color-option" style="background-color: #333333; color: #dc143c;" data-color="Crimson" title="Crimson">Crimson</div>
                </div>
                <div class="color-row">
                    <div class="color-option" style="background-color: #333333; color: #0000ff;" data-color="Blue" title="Blue">Blue</div>
                    <div class="color-option" style="background-color: #333333; color: #800080;" data-color="Purple" title="Purple">Purple</div>
                </div>
                <div class="color-row">
                    <div class="color-option" style="background-color: #333333; color: #ffa500;" data-color="Orange" title="Orange">Orange</div>
                    <div class="color-option" style="background-color: #333333; color: #00ff00;" data-color="Green" title="Green">Green</div>
                </div>
                <div class="color-row">
                    <div class="color-option" style="background-color: #333333; color: #ffd700;" data-color="Gold" title="Gold">Gold</div>
                    <div class="color-option" style="background-color: #333333; color: #c0c0c0;" data-color="Silver" title="Silver">Silver</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Shape Menu (shown after color selection) -->
    <div id="shape-menu" class="context-menu">
        <div class="context-menu-section">
            <div class="context-menu-title">Select Shape</div>
            <div class="shape-options" id="shape-options-container">
                <!-- Shape options will be dynamically populated with preview images -->
            </div>
        </div>
    </div>

    <!-- Crosshair for anchor point placement -->
    <div id="crosshair" class="crosshair">
        <div class="crosshair-h"></div>
        <div class="crosshair-v"></div>
        <div class="crosshair-center"></div>
    </div>

    <script>
        // Initialize Alt1 globals
        window.alt1 = window.alt1 || null;

        // Document ready function
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Document loaded");
            
            // Setup Alt1 status
            setupAlt1();
            
            // Periodically check Alt1 status
            setInterval(setupAlt1, 5000);
            
            // Load settings from localStorage
            loadSettings();
            
            // Update map size based on settings
            updateMapSize();
            
            // Initialize grid
            initializeGrid();
        });

        // Check if Alt1 is available and setup installation
        function setupAlt1() {
            const statusIndicatorDiv = document.getElementById('alt1-status-indicator');
            
            if (window.alt1) {
                // Alt1 detected, identify the app
                alt1.identifyAppUrl("./appconfig.json");
                
                // Update the status indicator
                statusIndicatorDiv.innerHTML = `
                    <div class="status-item"><span class="status-label">Alt1:</span> <span class="status-value status-ok">Detected</span></div>
                `;
            } else {
                // Alt1 not detected, create installation link
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.substring(0, currentUrl.lastIndexOf('/') + 1);
                const addappurl = `alt1://addapp/${baseUrl}appconfig.json`;
                
                // Update the status indicator
                statusIndicatorDiv.innerHTML = `
                    <div class="status-item"><span class="status-label">Alt1:</span> <span class="status-value status-error">Not Detected</span></div>
                `;
            }
        }

        // Function to show a specific view
        function showView(viewId, clickedItem) {
            console.log("Show view called for:", viewId);
            
            // Update active nav item
            var navItems = document.querySelectorAll(".nav-item");
            navItems.forEach(function(item) {
                item.classList.remove("active");
            });
            clickedItem.classList.add("active");
            
            // Update active view
            var views = document.querySelectorAll(".view");
            views.forEach(function(view) {
                view.classList.remove("active");
            });
            
            var viewToShow = document.getElementById(viewId);
            if (viewToShow) {
                viewToShow.classList.add("active");
            }

            // Reset any custom styles applied to views
            resetViewStyles();

            // If switching to map view, update the map size
            if (viewId === 'map-view') {
                updateMapSize();
                // Enable compact mode for map view
                document.body.classList.add('compact-mode');
            }
        }

        // Function to reset view styles
        function resetViewStyles() {
            // Reset any inline styles applied to views
            document.querySelectorAll('.view').forEach(function(view) {
                view.style.display = '';
                view.style.flexDirection = '';
                view.style.alignItems = '';
                view.style.justifyContent = '';
            });
            
            // Remove compact mode
            document.body.classList.remove('compact-mode');
            
            // Don't hide crosshair if we're setting an anchor point
            if (!isSettingAnchorPoint) {
                const crosshair = document.getElementById('crosshair');
                if (crosshair) {
                    crosshair.classList.remove('active');
                }
            }
        }

        // Settings management
        let settings = {
            dungeonSize: "small", // Default value
            mapState: {}, // Store cell states here
            anchorPoint: null // Store anchor point coordinates
        };

        // Function to save a specific setting
        function saveSetting(key, value) {
            settings[key] = value;
            console.log(`Setting ${key} updated to: ${value}`);
            
            // Auto-save to localStorage
            localStorage.setItem("dungeonSettings", JSON.stringify(settings));
            console.log("Settings auto-saved to localStorage");
            
            // Show save feedback
            showSaveFeedback();
            
            // Apply changes immediately
            if (key === 'dungeonSize') {
                updateMapSize();
            }
        }
        
        // Function to show save feedback
        function showSaveFeedback() {
            const feedback = document.getElementById('save-feedback');
            if (!feedback) return;
            
            feedback.textContent = 'Settings saved!';
            feedback.classList.add('visible');
            
            // Hide the feedback after 2 seconds
            setTimeout(() => {
                feedback.classList.remove('visible');
            }, 2000);
        }

        // Function to update dungeon size
        function updateDungeonSize(value) {
            saveSetting('dungeonSize', value);
            updateCapturePreviewSize();
        }

        // Function to update map size based on settings
        function updateMapSize() {
            const mapContainer = document.getElementById('map-container');
            const mapGrid = document.getElementById('map-grid');
            
            if (!mapContainer || !mapGrid) return;
            
            // Remove all size classes
            mapContainer.classList.remove('small', 'medium', 'large');
            mapGrid.classList.remove('small', 'medium', 'large');
            
            // Add the appropriate size class
            mapContainer.classList.add(settings.dungeonSize);
            mapGrid.classList.add(settings.dungeonSize);
            
            // Clear and recreate grid cells
            mapGrid.innerHTML = '';
            createGridCells(settings.dungeonSize);
        }
        
        // Function to create grid cells based on dungeon size
        function createGridCells(size) {
            const mapGrid = document.getElementById('map-grid');
            if (!mapGrid) return;
            
            let rows = 4, cols = 4;
            
            switch(size) {
                case 'small':
                    rows = 4;
                    cols = 4;
                    break;
                case 'medium':
                    rows = 8;
                    cols = 4;
                    break;
                case 'large':
                    rows = 8;
                    cols = 8;
                    break;
            }
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    // Add event listener for right-click to show context menu
                    cell.addEventListener('contextmenu', function(e) {
                        e.preventDefault();
                        showContextMenu(e, cell);
                    });
                    
                    mapGrid.appendChild(cell);
                }
            }
        }
        
        // Variables to track the currently active cell and selected color
        let activeCell = null;
        let selectedColor = null;
        
        // Function to show the context menu
        function showContextMenu(event, cell) {
            console.log("showContextMenu called", event, cell);
            
            const contextMenu = document.getElementById('context-menu');
            if (!contextMenu) {
                console.error("Context menu element not found");
                return;
            }
            
            // Set the active cell
            activeCell = cell;
            
            // Reset selected color
            selectedColor = null;
            
            // Position based on the current dungeon size
            let posX, posY;
            
            // Get the current dungeon size from settings
            const dungeonSize = settings.dungeonSize;
            
            // Adjust position based on dungeon size
            if (dungeonSize === 'small') {
                posX = 38;
                posY = 20;
            } else if (dungeonSize === 'medium') {
                posX = 38;
                posY = 100;
            } else if (dungeonSize === 'large') {
                posX = 107;
                posY = 90;
            } else {
                // Default fallback
                posX = 30;
                posY = 20;
            }
            
            // Position the context menu
            contextMenu.style.left = `${posX}px`;
            contextMenu.style.top = `${posY}px`;
            
            // Make the context menu visible
            contextMenu.classList.add('visible');
            
            // Add event listeners to color options
            document.querySelectorAll('.color-option').forEach(option => {
                option.onclick = function() {
                    console.log("Color option clicked:", this.dataset.color);
                    selectedColor = this.dataset.color;
                    hideContextMenu();
                    showShapeMenu();
                };
            });
            
            // Add a click event listener to the document to hide the context menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu);
            }, 0);
            
            // Prevent the default context menu
            event.preventDefault();
            event.stopPropagation();
            return false;
        }
        
        // Function to show the shape menu after color selection
        function showShapeMenu() {
            console.log("showShapeMenu called with color:", selectedColor);
            
            const shapeMenu = document.getElementById('shape-menu');
            if (!shapeMenu) {
                console.error("Shape menu element not found");
                return;
            }
            
            const shapeOptionsContainer = document.getElementById('shape-options-container');
            if (!shapeOptionsContainer) {
                console.error("Shape options container not found");
                return;
            }
            
            // Clear previous shape options
            shapeOptionsContainer.innerHTML = '';
            
            // Define available shapes
            const shapes = [
                "pentagon", "triangle", "shield", "wedge", 
                "rectangle", "crescent", "corner", "diamond"
            ];
            
            // Create shape rows for two-column layout
            for (let i = 0; i < shapes.length; i += 2) {
                const shapeRow = document.createElement('div');
                shapeRow.className = 'shape-row';
                
                // Create first shape option in the row
                const shapeOption1 = createShapeOption(shapes[i]);
                shapeRow.appendChild(shapeOption1);
                
                // Create second shape option if available
                if (i + 1 < shapes.length) {
                    const shapeOption2 = createShapeOption(shapes[i + 1]);
                    shapeRow.appendChild(shapeOption2);
                }
                
                // Add row to container
                shapeOptionsContainer.appendChild(shapeRow);
            }
            
            // Position based on the current dungeon size - use the same position as the color menu
            let posX, posY;
            
            // Get the current dungeon size from settings
            const dungeonSize = settings.dungeonSize;
            
            // Adjust position based on dungeon size - use the same values as in showContextMenu
            if (dungeonSize === 'small') {
                posX = 38;
                posY = 20;
            } else if (dungeonSize === 'medium') {
                posX = 38;
                posY = 100;
            } else if (dungeonSize === 'large') {
                posX = 107;
                posY = 90;
            } else {
                // Default fallback
                posX = 30;
                posY = 20;
            }
            
            // Position the shape menu
            shapeMenu.style.left = `${posX}px`;
            shapeMenu.style.top = `${posY}px`;
            
            // Make the shape menu visible
            shapeMenu.classList.add('visible');
            
            // Add a click event listener to the document to hide the shape menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', hideShapeMenu);
            }, 0);
        }
        
        // Helper function to create a shape option
        function createShapeOption(shape) {
            const shapeOption = document.createElement('div');
            shapeOption.className = 'shape-option';
            shapeOption.dataset.shape = shape;
            shapeOption.title = shape.charAt(0).toUpperCase() + shape.slice(1);
            
            // Create preview image
            const previewImg = document.createElement('img');
            previewImg.className = 'shape-preview';
            previewImg.src = `../assets/keys/${selectedColor}_${shape}_key.png`;
            previewImg.alt = `${selectedColor} ${shape}`;
            
            // Add shape name
            const shapeName = document.createElement('span');
            shapeName.textContent = shape.charAt(0).toUpperCase() + shape.slice(1);
            shapeName.style.fontSize = '9px';
            
            // Add to shape option
            shapeOption.appendChild(previewImg);
            shapeOption.appendChild(shapeName);
            
            // Add click event
            shapeOption.onclick = function() {
                console.log("Shape option clicked:", this.dataset.shape);
                applyKeyToCell(selectedColor, this.dataset.shape);
                hideShapeMenu();
            };
            
            return shapeOption;
        }
        
        // Function to hide the context menu
        function hideContextMenu(event) {
            console.log("hideContextMenu called");
            const contextMenu = document.getElementById('context-menu');
            if (contextMenu) {
                contextMenu.classList.remove('visible');
            }
            document.removeEventListener('click', hideContextMenu);
        }
        
        // Function to hide the shape menu
        function hideShapeMenu(event) {
            console.log("hideShapeMenu called");
            const shapeMenu = document.getElementById('shape-menu');
            if (shapeMenu) {
                shapeMenu.classList.remove('visible');
            }
            document.removeEventListener('click', hideShapeMenu);
        }
        
        // Function to apply a key image to the active cell
        function applyKeyToCell(color, shape) {
            if (!activeCell || !color || !shape || color === 'none' || shape === 'none') return;
            
            // Remove any existing image
            const existingImg = activeCell.querySelector('img');
            if (existingImg) {
                activeCell.removeChild(existingImg);
            }
            
            // Store the color and shape as data attributes
            activeCell.dataset.color = color;
            activeCell.dataset.shape = shape;
            
            // Add the key image
            const img = document.createElement('img');
            img.src = `../assets/keys/${color}_${shape}_key.png`;
            img.alt = `${color} ${shape} key`;
            activeCell.appendChild(img);
            
            // Save the cell state
            saveCellState(activeCell);
        }
        
        // Function to save the state of a cell
        function saveCellState(cell) {
            const row = cell.dataset.row;
            const col = cell.dataset.col;
            
            // Get the current color and shape
            const color = cell.dataset.color || '';
            const shape = cell.dataset.shape || '';
            
            // Create a cell state object
            const cellState = { row, col, color, shape };
            
            // Get the current map state from settings or initialize a new one
            if (!settings.mapState) {
                settings.mapState = {};
            }
            
            // Create a key for this cell
            const cellKey = `${row}-${col}`;
            
            // Save the cell state
            settings.mapState[cellKey] = cellState;
            
            // Save to localStorage
            localStorage.setItem("dungeonSettings", JSON.stringify(settings));
            console.log(`Cell state saved for ${row},${col}`);
        }
        
        // Function to load cell states from settings
        function loadCellStates() {
            if (!settings.mapState) return;
            
            // Get all grid cells
            const cells = document.querySelectorAll('.grid-cell');
            
            // Loop through each cell
            cells.forEach(cell => {
                const row = cell.dataset.row;
                const col = cell.dataset.col;
                const cellKey = `${row}-${col}`;
                
                // Check if we have a saved state for this cell
                if (settings.mapState[cellKey]) {
                    const state = settings.mapState[cellKey];
                    
                    // Apply the color and shape
                    if (state.color && state.shape && state.color !== 'none' && state.shape !== 'none') {
                        cell.dataset.color = state.color;
                        cell.dataset.shape = state.shape;
                        
                        const img = document.createElement('img');
                        img.src = `../assets/keys/${state.color}_${state.shape}_key.png`;
                        img.alt = `${state.color} ${state.shape} key`;
                        cell.appendChild(img);
                    }
                }
            });
        }
        
        // Update the initializeGrid function to also load cell states
        function initializeGrid() {
            // Create initial grid cells
            createGridCells(settings.dungeonSize);
            
            // Load saved cell states
            loadCellStates();
        }
        
        // Function to load settings from localStorage
        function loadSettings() {
            console.log("Loading settings from localStorage");
            
            const savedSettings = localStorage.getItem("dungeonSettings");
            console.log("Raw saved settings:", savedSettings);
            
            if (savedSettings) {
                try {
                    settings = JSON.parse(savedSettings);
                    console.log("Parsed settings:", settings);
                    console.log("Anchor point from loaded settings:", settings.anchorPoint);
                    
                    // Apply saved settings to form elements
                    document.getElementById("dungeon-size").value = settings.dungeonSize;
                    
                    // Update anchor point status
                    const anchorStatus = document.getElementById('anchor-status');
                    if (anchorStatus) {
                        anchorStatus.textContent = settings.anchorPoint ? "Set" : "Not set";
                        anchorStatus.className = "status-text " + (settings.anchorPoint ? "anchor-active" : "anchor-inactive");
                    }
                    
                    // Update anchor point display
                    updateAnchorPointDisplay();
                } catch (e) {
                    console.error("Error loading saved settings:", e);
                }
            } else {
                console.log("No saved settings found");
            }
        }
        
        // Variables for anchor point placement
        let isSettingAnchorPoint = false;
        let anchorPointInterval = null;
        
        // Function to start anchor point placement
        function startAnchorPointPlacement() {
            if (isSettingAnchorPoint) return;
            
            console.log("Starting anchor point placement");
            isSettingAnchorPoint = true;
            
            // Update UI
            const anchorStatus = document.getElementById('anchor-status');
            const setAnchorButton = document.getElementById('set-anchor-button');
            
            if (anchorStatus) {
                anchorStatus.textContent = "Press SPACE to set anchor point";
                anchorStatus.className = "status-text anchor-active";
            }
            
            if (setAnchorButton) {
                setAnchorButton.textContent = "Cancel";
                setAnchorButton.onclick = cancelAnchorPointPlacement;
            }
            
            // Show crosshair
            const crosshair = document.getElementById('crosshair');
            if (crosshair) {
                crosshair.classList.add('active');
            }
            
            // Start tracking mouse position
            anchorPointInterval = setInterval(updateCrosshairPosition, 50);
            
            // Add space key listener
            document.addEventListener('keydown', handleAnchorKeyPress);
        }
        
        // Function to update crosshair position
        function updateCrosshairPosition() {
            if (!window.alt1) return;
            
            const mousePos = getAlt1MousePosition();
            if (!mousePos) return;
            
            const crosshair = document.getElementById('crosshair');
            if (!crosshair) return;
            
            crosshair.style.left = `${mousePos.x - 50}px`;
            crosshair.style.top = `${mousePos.y - 50}px`;
            crosshair.style.width = '100px';
            crosshair.style.height = '100px';
        }

        // Function to get Alt1 mouse position
        function getAlt1MousePosition() {
            if (!window.alt1) {
                console.log("Alt1 not available");
                return null;
            }
            
            try {
                const pos = alt1.mousePosition;
                console.log("Raw Alt1 mouse position:", pos);
                
                if (pos === -1) {
                    console.log("Invalid mouse position (-1)");
                    return null;
                }
                
                const x = pos >>> 16;
                const y = pos & 0xFFFF;
                console.log("Decoded mouse position:", { x, y });
                
                return {
                    x: x,
                    y: y
                };
            } catch (e) {
                console.error("Error getting mouse position:", e);
                return null;
            }
        }
        
        // Function to handle key press during anchor point placement
        function handleAnchorKeyPress(e) {
            if (e.code === 'Space' || e.key === ' ') {
                e.preventDefault();
                setAnchorPoint();
            } else if (e.code === 'Escape' || e.key === 'Escape') {
                e.preventDefault();
                cancelAnchorPointPlacement();
            }
        }
        
        // Function to set the anchor point
        function setAnchorPoint() {
            console.log("setAnchorPoint called");
            
            if (!isSettingAnchorPoint) {
                console.log("Not in anchor point setting mode");
                return;
            }
            
            if (!window.alt1) {
                console.log("Alt1 not available");
                return;
            }
            
            const mousePos = getAlt1MousePosition();
            console.log("Mouse position from getAlt1MousePosition:", mousePos);
            
            if (!mousePos) {
                console.log("Failed to get mouse position");
                return;
            }
            
            // Save anchor point
            settings.anchorPoint = {
                x: mousePos.x,
                y: mousePos.y
            };
            
            console.log("Anchor point saved:", settings.anchorPoint);
            
            // Save settings
            localStorage.setItem("dungeonSettings", JSON.stringify(settings));
            console.log("Settings saved to localStorage");
            
            // Update UI
            updateAnchorPointDisplay();
            
            // End placement mode
            endAnchorPointPlacement();
            
            // Show feedback
            showSaveFeedback();
        }
        
        // Function to cancel anchor point placement
        function cancelAnchorPointPlacement() {
            console.log("Cancelling anchor point placement");
            endAnchorPointPlacement();
        }
        
        // Function to end anchor point placement mode
        function endAnchorPointPlacement() {
            isSettingAnchorPoint = false;
            
            // Update UI
            const anchorStatus = document.getElementById('anchor-status');
            const setAnchorButton = document.getElementById('set-anchor-button');
            
            if (anchorStatus) {
                anchorStatus.textContent = settings.anchorPoint ? "Set" : "Not set";
                anchorStatus.className = "status-text " + (settings.anchorPoint ? "anchor-active" : "anchor-inactive");
            }
            
            if (setAnchorButton) {
                setAnchorButton.textContent = "Set Anchor";
                setAnchorButton.onclick = startAnchorPointPlacement;
            }
            
            // Hide crosshair
            const crosshair = document.getElementById('crosshair');
            if (crosshair) {
                crosshair.classList.remove('active');
            }
            
            // Stop tracking mouse position
            if (anchorPointInterval) {
                clearInterval(anchorPointInterval);
                anchorPointInterval = null;
            }
            
            // Remove space key listener
            document.removeEventListener('keydown', handleAnchorKeyPress);
        }
        
        // Function to update anchor point display
        function updateAnchorPointDisplay() {
            console.log("updateAnchorPointDisplay called");
            
            const coordinatesDisplay = document.getElementById('anchor-coordinates');
            if (!coordinatesDisplay) {
                console.log("Coordinates display element not found");
                return;
            }
            
            console.log("Current settings.anchorPoint:", settings.anchorPoint);
            
            if (settings.anchorPoint) {
                const displayText = `X: ${settings.anchorPoint.x}, Y: ${settings.anchorPoint.y}`;
                console.log("Setting coordinates display to:", displayText);
                coordinatesDisplay.textContent = displayText;
            } else {
                console.log("No anchor point set, displaying undefined");
                coordinatesDisplay.textContent = 'X: undefined, Y: undefined';
            }
        }

        // Load settings and initialize the app on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Try to load saved settings
            loadSettings();
            
            // Update anchor point display
            updateAnchorPointDisplay();
            
            // Initialize Alt1 status
            updateAlt1Status();
            
            // Initialize screen capture preview
            initScreenCapturePreview();
            
            // Check if we're running in Alt1
            if (window.alt1) {
                console.log("Running in Alt1 browser");
                document.body.classList.add('alt1-mode');
            }
            
            console.log("Re-initializing context menu event listeners");
            
            // Add right-click event listeners to all grid cells
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.addEventListener('contextmenu', function(e) {
                    console.log("Context menu event triggered on cell");
                    e.preventDefault();
                    showContextMenu(e, this);
                    return false;
                });
            });
        });
        
        // Function to update Alt1 status
        function updateAlt1Status() {
            const statusIndicator = document.getElementById('alt1-status-indicator');
            if (!statusIndicator) return;
            
            if (window.alt1) {
                let statusHTML = '<div class="status-item"><span class="status-label">Alt1:</span> <span class="status-value status-ok">Detected</span></div>';
                
                // Check pixel permission
                statusHTML += '<div class="status-item"><span class="status-label">Pixel Permission:</span> ';
                statusHTML += window.alt1.permissionPixel ? 
                    '<span class="status-value status-ok">Granted</span>' : 
                    '<span class="status-value status-error">Not Granted</span>';
                statusHTML += '</div>';
                
                // Check overlay permission
                statusHTML += '<div class="status-item"><span class="status-label">Overlay Permission:</span> ';
                statusHTML += window.alt1.permissionOverlay ? 
                    '<span class="status-value status-ok">Granted</span>' : 
                    '<span class="status-value status-error">Not Granted</span>';
                statusHTML += '</div>';
                
                statusIndicator.innerHTML = statusHTML;
            } else {
                // Generate Alt1 install URL
                const appUrl = encodeURIComponent(window.location.href);
                const addappurl = `alt1://addapp/${appUrl}`;
                
                statusIndicator.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Alt1:</span> 
                        <span class="status-value status-error">Not Detected</span>
                    </div>
                    <div class="status-item">
                        <a href='${addappurl}' class="alt1-install-link">Install in Alt1</a>
                    </div>
                `;
            }
        }
        
        // Screen capture preview functions
        let capturePreviewInterval = null;
        
        // Function to initialize screen capture preview
        function initScreenCapturePreview() {
            const canvas = document.getElementById('capturePreviewCanvas');
            if (!canvas) return;
            
            // Set initial canvas size based on dungeon size
            updateCapturePreviewSize();
            
            // Start the preview update interval
            startCapturePreview();
        }
        
        // Function to start capture preview updates
        function startCapturePreview() {
            if (capturePreviewInterval) {
                clearInterval(capturePreviewInterval);
            }
            
            capturePreviewInterval = setInterval(updateCapturePreview, 1000); // Update every second
            updateCapturePreview(); // Initial update
        }
        
        // Function to stop capture preview updates
        function stopCapturePreview() {
            if (capturePreviewInterval) {
                clearInterval(capturePreviewInterval);
                capturePreviewInterval = null;
            }
        }
        
        // Function to update capture preview size based on dungeon size
        function updateCapturePreviewSize() {
            const canvas = document.getElementById('capturePreviewCanvas');
            if (!canvas) return;
            
            // Set canvas size based on dungeon size
            switch(settings.dungeonSize) {
                case 'small':
                    canvas.width = 140;
                    canvas.height = 140;
                    break;
                case 'medium':
                    canvas.width = 140;
                    canvas.height = 280;
                    break;
                case 'large':
                    canvas.width = 280;
                    canvas.height = 280;
                    break;
            }
            
            // Clear the canvas
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw a border
            ctx.strokeStyle = '#43b581';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
        }
        
        // Function to update the capture preview
        function updateCapturePreview() {
            if (!window.alt1 || !window.alt1.permissionPixel) {
                console.log("Alt1 not available or pixel permission not granted");
                return;
            }
            
            const canvas = document.getElementById('capturePreviewCanvas');
            if (!canvas) return;
            
            // Check if anchor point is set
            if (!settings.anchorPoint) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#202225';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#dcddde';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Set anchor point first', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            try {
                // Calculate capture region (anchor point is top-right corner)
                const captureRegion = getCaptureRegion();
                
                // Capture the screen
                const img = window.a1lib.captureHoldFullRs();
                if (!img) {
                    console.error("Failed to capture screen");
                    return;
                }
                
                // Extract the region
                const imgData = img.toData(
                    captureRegion.x, 
                    captureRegion.y, 
                    captureRegion.width, 
                    captureRegion.height
                );
                
                // Draw to canvas
                const ctx = canvas.getContext('2d');
                ctx.putImageData(imgData, 0, 0);
                
                // Draw a border
                ctx.strokeStyle = '#43b581';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
                
                // Draw overlay in game
                updateGameOverlay(captureRegion);
            } catch (error) {
                console.error("Error updating capture preview:", error);
            }
        }
        
        // Function to calculate capture region based on anchor point
        function getCaptureRegion() {
            // Get canvas dimensions
            const canvas = document.getElementById('capturePreviewCanvas');
            const width = canvas.width;
            const height = canvas.height;
            
            // Anchor point is top-right corner of capture area
            const x = settings.anchorPoint.x - width;
            const y = settings.anchorPoint.y;
            
            return {
                x: x,
                y: y,
                width: width,
                height: height
            };
        }
        
        // Function to update game overlay
        function updateGameOverlay(region) {
            if (!window.alt1 || !window.alt1.permissionOverlay) {
                return;
            }
            
            try {
                // Clear previous overlay
                window.alt1.overLayClearGroup("capture_preview_overlay");
                
                // Set overlay group
                window.alt1.overLaySetGroup("capture_preview_overlay");
                
                // Draw rectangle overlay
                window.alt1.overLayRect(
                    0x00FF00, // Green color
                    region.x,
                    region.y,
                    region.width,
                    region.height,
                    2000, // Duration in ms
                    2 // Line thickness
                );
                
                // Refresh the overlay
                window.alt1.overLayRefreshGroup("capture_preview_overlay");
            } catch (error) {
                console.warn("Error updating game overlay:", error);
            }
        }
    </script>
    <!-- Include the bundled JavaScript file -->
    <script src="index.bundle.js"></script>
</body>
</html>
